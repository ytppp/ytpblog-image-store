---
title: Vue3 学习笔记
date: 2021-01-04 00:00:00
categories:
  - 前端
  - 前端综合
tags:
  - Vue3
  - TypeScript
permalink: /pages/7e5fcc/
---

# Vue3 学习笔记

Vue3 中一些相较于 Vue2 变化与新语法的学习笔记。

<!-- more -->

<!-- ## 文章目录

- template 的变化
- 新增语法
  - setUp
  - ref
  - reactive
  - toRefs
- 生命周期的变化
- watch 的变化
- computed 的变化
- 新增标签
  - Teleport
  - Suspense
- 自定义 HOOKS
- 结合 TypeScript 开发组件 -->

## template 的变化

在 Vue2 中，每个 template 节点只能有一个根节点：

```vue
<template>
  <div>123</div>
</template>
```

而在 Vue3 中，可以有多个根节点:

```vue
<template>
  <div>123</div>
  <div>456</div>
  <router-view />
</template>
```

这种变化，让我们在开发过程中，减少了不必要`html标签`的书写。例如下面这个例子：

```vue
<template>
  <table>
    <tr>
      <columns />
    </tr>
  </table>
</template>
```

`<columns />`需要返回多个`<td>`元素以使渲染的`HTML`有效。如果在`<columns />`中使用了父 div，则生成的 HTML 将无效。

```vue
<template>
  <div>
    <td>Hello</td>
    <td>World</td>
  </div>
</template>
```

得到一个`<Table />`输出：

```vue
<template>
  <table>
    <tr>
      <div>
        <td>Hello</td>
        <td>World</td>
      </div>
    </tr>
  </table>
</template>
```

Vue3 中 Template 的变化解决了这个问题。

## 新增语法

### setUp

这个代替了原来的`data方法`，它可以接收两个参数，`props`和`context`(没有用到的时候可以省略不写)，且**只执行一次**。

```vue
<template>
  <div>
    <h1>num:{{ num }}</h1>
  </div>
  <button @click="add">加1</button>
</template>

<script lang="js">
export default {
  name: 'App',
  setup() {
    let num = 0;
    const add = () => {
      num++;
    };
    console.log(num);
    return {
      add,
      num,
    };
  },
};
</script>
```

这是一个基本的`setup`的过程。可以试着点击一下按钮，发现`num`并没有发生改变。看一下控制台，发现输出的是一个`number`的值。但我们点击并没有发生改变。所以接下来，我们将用到第一个新的 API **Ref**。

### ref

首先，我们改造下上面的代码：

```vue
<template>
  <div>
    <h1>msg:{{ msg }}</h1>
    <h1>num:{{ num }}</h1>
  </div>
  <button @click="add">加1</button>
</template>

<script lang="js">
import { ref } from 'vue';

export default {
  name: 'App',
  setup() {
    const msg = ref(0);
    let num = 0;
    const add = () => {
      msg.value++;
      num++;
    };
    console.log(msg);
    console.log(num);
    return {
      msg,
      add,
      num,
    };
  },
};
</script>
```

首先，先看下`ref`的导入方式，可以看到这里是**按需导入**，按需导入的好处大家都懂。我们再看下这里的**控制台**的输出，就会发现：`msg`打印是`RefImpl`，`num`打印是数值`0`。点击按钮发现，`msg`可以改变，而`num`不行。

`RefImpl`是什么呢？我把它理解为**代理对象**。就比如我们知道`Vue2`中`data`的数据是通过`Object.defineProperty()`来进行拦截。从而达到**数据响应式**的目的。而`Vue3`是利用了`ES6`中的`proxy`，相对于`Object.defineProperty()`来说，能拦截的方式更多。功能也更加强大。

:::tip
`ref`是一个函数，它接受一个参数，返回的就是一个响应式对象。例子中，我们初始化的这个`0`作为参数包裹到这个对象中去，在未来操作这个值的时候，可以检测到改变并作出对应的相应。
:::

如果想创建一个对象的反应式状态呢？这时就不能使用`ref`了，就要使用接下来这个方式**reactive**。

### reactive

创建一个对象的反应式状态，就要使用`reactive`方法。示例代码:

```vue
<template>
  <div>
    <h1>count:{{ obj.count }}</h1>
    <h1>double:{{ obj.double }}</h1>
  </div>
  <button @click="obj.increase">加1</button>
</template>

<script lang="js">
import { reactive, computed } from 'vue';

export default {
  name: 'App',
  setup() {
    const obj = reactive({
      count: 0,
      increase: () => {
        obj.count++;
      },
      double: computed(() => obj.count * 2), // 这里是computed在vue3中的用法
    });
    return {
      obj,
    };
  },
};
</script>
```

这时候我们点击按钮就可以改变状态了。但像`{{obj.count}}`这样写的时候有些繁琐，这里我们可以**解构**下`obj`。如下：

```vue
<template>
  <div>
    <h1>count:{{ count }}</h1>
    <h1>double:{{ double }}</h1>
  </div>
  <button @click="increase">加1</button>
</template>

<script lang="js">
import { reactive, computed } from 'vue';

export default {
  name: 'App',
  setup() {
    const obj = reactive({
      count: 0,
      increase: () => {
        obj.count++;
      },
      double: computed(() => obj.count * 2),
    });
    return {
      ...obj,
    };
  },
};
</script>
```

这时候大家会发现一个问题。为什么点击按钮不改变状态了呢？这是因为，解构会破坏代理，把他变成一个普通值。就跟上面的`Ref`的例子一样，所以点击按钮并没有发生变化。这时候，就要请出另外一个新加的`api`了，`toRefs`:

### toRefs

使用起来 比较简单，就返回的时候加上就可以:

```vue
<template>
  <div>
    <h1>count:{{ count }}</h1>
    <h1>double:{{ double }}</h1>
  </div>
  <button @click="increase">加1</button>
</template>

<script lang="js">
import { reactive, computed, toRefs } from 'vue';

export default {
  name: 'App',
  setup() {
    const data = reactive({
      count: 0,
      increase: () => {
        data.count++;
      },
      double: computed(() => data.count * 2),
    });
    return {
      ...toRefs(data),
    };
  },
};
</script>
```

:::tip
`toRefs`从组合函数返回反应对象时，此函数很有用，以便使用组件可以对返回的对象进行解构/扩展而不会失去反应性。——摘自官网
:::

## 生命周期的变化

| Vue2            | Vue3                           |
| --------------- | ------------------------------ |
| beforeCreate    | ~~beforeCreate~~,use `setup()` |
| created         | ~~created~~,use `setup()`      |
| beforeMount     | onBeforeMount                  |
| mounted         | onMounted                      |
| beforeUpdate    | onBeforeUpdate                 |
| updated         | onUpdated                      |
| beforeUnmount   | onBeforeUnmount                |
| unmounted       | onUnmounted                    |
| errorCaptured   | onErrorCaptured                |
| renderTracked   | onRenderTracked                |
| renderTriggered | onRenderTriggered              |

errorCaptured 当捕获一个来自子孙组件的错误时被调用。

示例：

```vue
<script lang="js">
export default {
  setup() {
    // mounted
    onMounted(() => {
      console.log('Componentis mounted!');
    });
  },
};
</script>
```

## watch 的变化

watch 在`vue3`中的用法与在`vue2`中的用法类似。

## computed 的变化

computed 在`vue3`中的用法与在`vue2`中的用法类似。但在`vue3`中，可以写在`reactive`内部，也可写在外部。

`watch`和`computed`的用法如下：

```vue
<script lang="js">
import { reactive, computed, watch, toRefs } from 'vue';

export default {
  setup() {
    const data = reactive({
      count: 0,
      increase: () => {
        data.count++;
      },
      double: computed(() => data.count * 2),
    });
    const conComputed = computed(() => data.count * 2);
    const number = ref(0);
    watch(data, () => {
      console.log(data);
      document.title = 'updated ' + data.count;
    });
    watch(number, () => {
      console.log(number);
    });
    return {
      number,
      conComputed,
      ...toRefs(data),
    };
  },
};
</script>
```

:::
在`vue3`中,`watch`和`computed`都要先引入才能使用。
:::

## 新增标签

### Teleport

平时我们的遮罩层都存在于某个多级标签下面，这样其实是不合理的。`Teleport`的出现可以让我们写的组件移动到指定标签下面。`to`是要移动到哪个标签下，它支持选择器。

示例代码如下：

```vue
<template>
  <teleport to="#modal">
    <div id="center">
      <h1>this is a modal</h1>
    </div>
  </teleport>
</template>

<script lang="js">
export default {
  name: 'modal',
};
</script>

<style scoped>
#center {
  width: 200px;
  height: 200px;
  background: red;
  position: fixed;
  left: 50%;
  top: 50%;
  margin-left: -100px;
  margin-top: -100px;
}
</style>
```

```vue
<template>
  <div id="modal">
    <div>
      <div>
        <modal v-if="show"></modal>
      </div>
    </div>
  </div>
  <button @click="show = !show">show</button>
</template>

<script lang="js">
import { ref } from 'vue';
import Modal from './components/modal.vue';

export default {
  name: 'App',
  components: {
    Modal,
  },
  setup() {
    const show = ref(false);
    return {
      show,
    };
  },
};
</script>
```

点击按钮之前：

<p align="center">
  <img src="https://cdn.jsdelivr.net/gh/ytppp/ytpblog-image-store/img/1609899006.jpg" width="500">
</p>

点击按钮之后：

<p align="center">
  <img src="https://cdn.jsdelivr.net/gh/ytppp/ytpblog-image-store/img/1609899624.jpg" width="500">
</p>

观察点击按钮前后的`DOM`结构，我们会发现，即使`modal`组件在`div#modal`下被嵌套了多层`div`后才使用，当显示时，它依然移动到`div#modal`下面。

### Suspense

Suspense 在异步请求的场景下是很实用的。下面举一个图片加载的场景说明：

```vue
<template>
  <img :src="result && result.url" alt="" />
</template>

<script lang="js">
import axios from 'axios';
import { defineComponent } from 'vue';

export default defineComponent({
  async setup() {
    const rawData = await axios.get('https://picsum.photos/id/786/200/200');
    console.log(rawData);
    return {
      result: rawData.config,
    };
  },
});
</script>
```

```vue
<template>
  <Suspense>
    <template #default>
      <pic-show />
    </template>
    <template #fallback>
      <h1>Loading...</h1>
    </template>
  </Suspense>
</template>

<script lang="js">
import PicShow from './components/pic-show.vue';

export default {
  name: 'App',
  components: {
    PicShow,
  },
};
</script>
```

效果如下：

<p align="center">
  <img src="https://cdn.jsdelivr.net/gh/ytppp/ytpblog-image-store/img/20210106110929.gif" width="500">
</p>

## 自定义 HOOKS

示例如下：

```typescript
<script lang="ts">
import { onMounted, onUnmounted, ref } from 'vue';

const useMousePosition = () => {
  const x = ref(0);
  const y = ref(0);
  const updateMouse = (e: MouseEvent) => {
    x.value = e.pageX;
    y.value = e.pageY;
  };

  onMounted(() => {
    document.addEventListener('mousemove', updateMouse);
  });

  onUnmounted(() => {
    document.removeEventListener('mousemove', updateMouse);
  });
  return { x, y };
};

export default useMousePosition;
</script>
```

```vue
<script lang="js">
import useMousePosition from '@/hooks/useMousePosition';

export default {
  setup() {
    const { x, y } = useMousePosition();
    return {
      x,
      y,
    };
  },
};
</script>
```

## 结合 TypeScript 开发组件

`defineComponent`创建组件需要用这个包裹。

示例如下：

```typescript
<script lang="ts">
import { defineComponent, PropType, computed } from 'vue';

// 把接口类型导出。在使用的过程中导入接口，对接口进行定义
export interface ColumnProps {
  id: number;
  title: string;
  avatar?: string;
  des: string;
}

export default defineComponent({
  name: 'ColumnList',
  props: {
    list: {
      type: Array as PropType<ColumnProps[]>,
      required: true,
    },
  },
  setup(props) {
    //  这里使用到了props
    const ColumnList = computed(() => {
      return props.list.map((item) => {
        if (!item.avatar) {
          item.avatar = require('@/assets/logo.png'); // 默认图片
        }
        return item;
      });
    });
    return {
      ColumnList,
    };
  },
});
</script>
```

```vue
<template>
  <div id="container">
    <column-list :list="list"></column-list>
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue';
import ColumnList, { ColumnProps } from '@/components/column-list.vue';

const testDate: ColumnProps[] = [
  {
    id: 1,
    title: 'test1',
    des: 'test1',
    avatar: 'https://picsum.photos/id/239/200/200',
  },
  {
    id: 2,
    title: 'test1',
    des: 'test1',
    avatar: 'https://picsum.photos/id/239/200/200',
  },
  {
    id: 3,
    title: 'test1',
    des: 'test1',
    avatar: 'https://picsum.photos/id/239/200/200',
  },
  {
    id: 4,
    title: 'test1',
    des: 'test1',
    avatar: 'https://picsum.photos/id/239/200/200',
  },
];
export default defineComponent({
  name: 'App',
  components: {
    ColumnList,
  },
  setup() {
    return {
      list: testDate,
    };
  },
});
</script>
```
